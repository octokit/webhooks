/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Schema =
  | CheckRunEvent
  | CheckSuiteEvent
  | CodeScanningAlertEvent
  | CommitCommentEvent
  | ContentReferenceEvent
  | CreateEvent
  | DeleteEvent
  | DeployKeyEvent
  | DeploymentEvent
  | DeploymentStatusEvent
  | ForkEvent
  | GithubAppAuthorizationEvent
  | GollumEvent
  | InstallationEvent
  | InstallationRepositoriesEvent
  | IssueCommentEvent
  | IssuesEvent
  | LabelEvent
  | MarketplacePurchaseEvent
  | MemberEvent
  | MembershipEvent
  | MetaEvent
  | MilestoneEvent
  | OrgBlockEvent
  | OrganizationEvent
  | PackageEvent
  | PageBuildEvent
  | PingEvent
  | ProjectEvent
  | ProjectCardEvent
  | ProjectColumnEvent
  | PublicEvent
  | PullRequestEvent
  | PullRequestReviewEvent
  | PullRequestReviewCommentEvent
  | PushEvent
  | ReleaseEvent
  | RepositoryEvent
  | RepositoryDispatchEvent
  | RepositoryImportEvent
  | RepositoryVulnerabilityAlertEvent
  | SecretScanningAlertEvent
  | SecurityAdvisoryEvent
  | SponsorshipEvent
  | StarEvent
  | StatusEvent
  | TeamEvent
  | TeamAddEvent
  | WatchEvent
  | WorkflowDispatchEvent
  | WorkflowRunEvent;
export type CheckRunEvent =
  | CheckRunCompletedEvent
  | CheckRunCreatedEvent
  | CheckRunRequestedActionEvent
  | CheckRunRerequestedEvent;
export type CheckSuiteEvent =
  | CheckSuiteCompletedEvent
  | CheckSuiteRequestedEvent
  | CheckSuiteRerequestedEvent;
export type CodeScanningAlertEvent =
  | CodeScanningAlertAppearedInBranchEvent
  | CodeScanningAlertClosedByUserEvent
  | CodeScanningAlertCreatedEvent
  | CodeScanningAlertFixedEvent
  | CodeScanningAlertReopenedEvent
  | CodeScanningAlertReopenedByUserEvent;
export type CommitCommentEvent = CommitCommentCreatedEvent;
/**
 * How the author is associated with the repository.
 */
export type AuthorAssociation =
  | "COLLABORATOR"
  | "CONTRIBUTOR"
  | "FIRST_TIMER"
  | "FIRST_TIME_CONTRIBUTOR"
  | "MANNEQUIN"
  | "MEMBER"
  | "NONE"
  | "OWNER";
export type ContentReferenceEvent = ContentReferenceCreatedEvent;
export type DeployKeyEvent = DeployKeyCreatedEvent | DeployKeyDeletedEvent;
export type DeploymentEvent = DeploymentCreatedEvent;
export type DeploymentStatusEvent = DeploymentStatusCreatedEvent;
export type GithubAppAuthorizationEvent = GithubAppAuthorizationRevokedEvent;
export type InstallationEvent =
  | InstallationCreatedEvent
  | InstallationDeletedEvent
  | InstallationNewPermissionsAcceptedEvent
  | InstallationSuspendEvent
  | InstallationUnsuspendEvent;
export type InstallationRepositoriesEvent =
  | InstallationRepositoriesAddedEvent
  | InstallationRepositoriesRemovedEvent;
export type IssueCommentEvent =
  | IssueCommentCreatedEvent
  | IssueCommentDeletedEvent
  | IssueCommentEditedEvent;
export type IssuesEvent =
  | IssuesAssignedEvent
  | IssuesClosedEvent
  | IssuesDeletedEvent
  | IssuesDemilestonedEvent
  | IssuesEditedEvent
  | IssuesLabeledEvent
  | IssuesLockedEvent
  | IssuesMilestonedEvent
  | IssuesOpenedEvent
  | IssuesPinnedEvent
  | IssuesReopenedEvent
  | IssuesTransferredEvent
  | IssuesUnassignedEvent
  | IssuesUnlabeledEvent
  | IssuesUnlockedEvent
  | IssuesUnpinnedEvent;
export type LabelEvent =
  | LabelCreatedEvent
  | LabelDeletedEvent
  | LabelEditedEvent;
export type MarketplacePurchaseEvent =
  | MarketplacePurchaseCancelledEvent
  | MarketplacePurchaseChangedEvent
  | MarketplacePurchasePendingChangeEvent
  | MarketplacePurchasePendingChangeCancelledEvent
  | MarketplacePurchasePurchasedEvent;
export type MemberEvent =
  | MemberAddedEvent
  | MemberEditedEvent
  | MemberRemovedEvent;
export type MembershipEvent = MembershipAddedEvent | MembershipRemovedEvent;
export type MetaEvent = MetaDeletedEvent;
export type MilestoneEvent =
  | MilestoneClosedEvent
  | MilestoneCreatedEvent
  | MilestoneDeletedEvent
  | MilestoneEditedEvent
  | MilestoneOpenedEvent;
export type OrgBlockEvent = OrgBlockBlockedEvent | OrgBlockUnblockedEvent;
export type OrganizationEvent =
  | OrganizationDeletedEvent
  | OrganizationMemberAddedEvent
  | OrganizationMemberInvitedEvent
  | OrganizationMemberRemovedEvent
  | OrganizationRenamedEvent;
export type PackageEvent = PackagePublishedEvent | PackageUpdatedEvent;
export type ProjectEvent =
  | ProjectClosedEvent
  | ProjectCreatedEvent
  | ProjectDeletedEvent
  | ProjectEditedEvent
  | ProjectReopenedEvent;
export type ProjectCardEvent =
  | ProjectCardConvertedEvent
  | ProjectCardCreatedEvent
  | ProjectCardDeletedEvent
  | ProjectCardEditedEvent
  | ProjectCardMovedEvent;
export type ProjectColumnEvent =
  | ProjectColumnCreatedEvent
  | ProjectColumnDeletedEvent
  | ProjectColumnEditedEvent
  | ProjectColumnMovedEvent;
export type PullRequestEvent =
  | PullRequestAssignedEvent
  | PullRequestAutoMergeDisabledEvent
  | PullRequestAutoMergeEnabledEvent
  | PullRequestClosedEvent
  | PullRequestConvertedToDraftEvent
  | PullRequestEditedEvent
  | PullRequestLabeledEvent
  | PullRequestLockedEvent
  | PullRequestOpenedEvent
  | PullRequestReadyForReviewEvent
  | PullRequestReopenedEvent
  | PullRequestReviewRequestRemovedEvent
  | PullRequestReviewRequestedEvent
  | PullRequestSynchronizeEvent
  | PullRequestUnassignedEvent
  | PullRequestUnlabeledEvent
  | PullRequestUnlockedEvent;
export type PullRequestReviewEvent =
  | PullRequestReviewDismissedEvent
  | PullRequestReviewEditedEvent
  | PullRequestReviewSubmittedEvent;
export type PullRequestReviewCommentEvent =
  | PullRequestReviewCommentCreatedEvent
  | PullRequestReviewCommentDeletedEvent
  | PullRequestReviewCommentEditedEvent;
export type ReleaseEvent =
  | ReleaseCreatedEvent
  | ReleaseDeletedEvent
  | ReleaseEditedEvent
  | ReleasePrereleasedEvent
  | ReleasePublishedEvent
  | ReleaseReleasedEvent
  | ReleaseUnpublishedEvent;
export type RepositoryEvent =
  | RepositoryArchivedEvent
  | RepositoryCreatedEvent
  | RepositoryDeletedEvent
  | RepositoryEditedEvent
  | RepositoryPrivatizedEvent
  | RepositoryPublicizedEvent
  | RepositoryRenamedEvent
  | RepositoryTransferredEvent
  | RepositoryUnarchivedEvent;
export type RepositoryDispatchEvent = RepositoryDispatchOnDemandTestEvent;
export type RepositoryVulnerabilityAlertEvent =
  | RepositoryVulnerabilityAlertCreateEvent
  | RepositoryVulnerabilityAlertDismissEvent
  | RepositoryVulnerabilityAlertResolveEvent;
export type SecretScanningAlertEvent =
  | SecretScanningAlertCreatedEvent
  | SecretScanningAlertReopenedEvent
  | SecretScanningAlertResolvedEvent;
export type SecurityAdvisoryEvent =
  | SecurityAdvisoryPerformedEvent
  | SecurityAdvisoryPublishedEvent
  | SecurityAdvisoryUpdatedEvent;
export type SponsorshipEvent =
  | SponsorshipCancelledEvent
  | SponsorshipCreatedEvent
  | SponsorshipEditedEvent
  | SponsorshipPendingCancellationEvent
  | SponsorshipPendingTierChangeEvent
  | SponsorshipTierChangedEvent;
export type StarEvent = StarCreatedEvent | StarDeletedEvent;
export type TeamEvent =
  | TeamAddedToRepositoryEvent
  | TeamCreatedEvent
  | TeamDeletedEvent
  | TeamEditedEvent
  | TeamRemovedFromRepositoryEvent;
export type WatchEvent = WatchStartedEvent;
export type WorkflowRunEvent =
  | WorkflowRunCompletedEvent
  | WorkflowRunRequestedEvent;

export interface CheckRunCompletedEvent {
  action: "completed";
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The phase of the lifecycle that the check is currently in.
     */
    status: "completed";
    /**
     * The final conclusion of the check. Can be one of `success`, `failure`, `neutral`, `cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion is `action_required`, additional details should be provided on the site specified by `details_url`.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check.
     */
    name: string;
    check_suite: {
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "in_progress" | "completed";
      conclusion:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "timed_out"
        | "action_required"
        | "stale"
        | null;
      url: string;
      before: string | null;
      after: string | null;
      pull_requests: {
        url: string;
        id: number;
        number: number;
        head: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
        base: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
      }[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
  };
  requested_action?: {
    identifier?: string;
  } | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepoRef {
  id: number;
  url: string;
  name: string;
}
/**
 * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export interface App {
  /**
   * Unique identifier of the GitHub app
   */
  id: number;
  /**
   * The slug name of the GitHub app
   */
  slug?: string;
  node_id: string;
  owner: User;
  /**
   * The name of the GitHub app
   */
  name: string;
  description: string | null;
  external_url: string;
  html_url: string;
  created_at: string;
  updated_at: string;
  /**
   * The set of permissions for the GitHub app
   */
  permissions?: {
    administration?: "read" | "write";
    actions?: "read" | "write";
    checks?: "read" | "write";
    contents?: "read" | "write";
    deployments?: "read" | "write";
    issues?: "read" | "write";
    members?: "read" | "write";
    metadata?: "read" | "write";
    organization_administration?: "read" | "write";
    organization_hooks?: "read" | "write";
    organization_packages?: "read" | "write";
    organization_plan?: "read" | "write";
    organization_projects?: "read" | "write";
    organization_user_blocking?: "read" | "write";
    pages?: "read" | "write";
    packages?: "read" | "write";
    pull_requests?: "read" | "write";
    repository_hooks?: "read" | "write";
    repository_projects?: "read" | "write";
    security_events?: "read" | "write";
    statuses?: "read" | "write";
    team_discussions?: "read" | "write";
    vulnerability_alerts?: "read" | "write";
  };
  /**
   * The list of events for the GitHub app
   */
  events?: string[];
}
export interface User {
  login: string;
  id: number;
  node_id: string;
  name?: string;
  email?: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: "Bot" | "User" | "Organization";
  site_admin: boolean;
}
/**
 * A git repository
 */
export interface Repository {
  /**
   * Unique identifier of the repository
   */
  id: number;
  node_id: string;
  /**
   * The name of the repository.
   */
  name: string;
  full_name: string;
  /**
   * Whether the repository is private or public.
   */
  private: boolean;
  owner: User;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  forks_url: string;
  keys_url: string;
  collaborators_url: string;
  teams_url: string;
  hooks_url: string;
  issue_events_url: string;
  events_url: string;
  assignees_url: string;
  branches_url: string;
  tags_url: string;
  blobs_url: string;
  git_tags_url: string;
  git_refs_url: string;
  trees_url: string;
  statuses_url: string;
  languages_url: string;
  stargazers_url: string;
  contributors_url: string;
  subscribers_url: string;
  subscription_url: string;
  commits_url: string;
  git_commits_url: string;
  comments_url: string;
  issue_comment_url: string;
  contents_url: string;
  compare_url: string;
  merges_url: string;
  archive_url: string;
  downloads_url: string;
  issues_url: string;
  pulls_url: string;
  milestones_url: string;
  notifications_url: string;
  labels_url: string;
  releases_url: string;
  deployments_url: string;
  created_at: number | string;
  updated_at: string;
  pushed_at: number | string;
  git_url: string;
  ssh_url: string;
  clone_url: string;
  svn_url: string;
  homepage: string | null;
  size: number;
  stargazers_count: number;
  watchers_count: number;
  language: string | null;
  /**
   * Whether issues are enabled.
   */
  has_issues: boolean;
  /**
   * Whether projects are enabled.
   */
  has_projects: boolean;
  /**
   * Whether downloads are enabled.
   */
  has_downloads: boolean;
  /**
   * Whether the wiki is enabled.
   */
  has_wiki: boolean;
  has_pages: boolean;
  forks_count: number;
  mirror_url: string | null;
  /**
   * Whether the repository is archived.
   */
  archived: boolean;
  /**
   * Returns whether or not this repository is disabled.
   */
  disabled?: boolean;
  open_issues_count: number;
  license: License | null;
  forks: number;
  open_issues: number;
  watchers: number;
  stargazers?: number;
  /**
   * The default branch of the repository.
   */
  default_branch: string;
  /**
   * Whether to allow squash merges for pull requests.
   */
  allow_squash_merge?: boolean;
  /**
   * Whether to allow merge commits for pull requests.
   */
  allow_merge_commit?: boolean;
  /**
   * Whether to allow rebase merges for pull requests.
   */
  allow_rebase_merge?: boolean;
  /**
   * Whether to delete head branches when pull requests are merged
   */
  delete_branch_on_merge?: boolean;
  master_branch?: string;
  permissions?: {
    pull: boolean;
    push: boolean;
    admin: boolean;
    maintain?: boolean;
    triage?: boolean;
  };
  public?: boolean;
  organization?: string;
}
export interface License {
  key: string;
  name: string;
  spdx_id: string;
  url: string | null;
  node_id: string;
}
/**
 * Installation
 */
export interface InstallationLite {
  /**
   * The ID of the installation.
   */
  id: number;
  node_id: string;
}
export interface Organization {
  login: string;
  id: number;
  node_id: string;
  url: string;
  html_url?: string;
  repos_url: string;
  events_url: string;
  hooks_url: string;
  issues_url: string;
  members_url: string;
  public_members_url: string;
  avatar_url: string;
  description: string | null;
}
export interface CheckRunCreatedEvent {
  action: "created";
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The phase of the lifecycle that the check is currently in.
     */
    status: "queued" | "in_progress";
    /**
     * The final conclusion of the check. Can be one of `success`, `failure`, `neutral`, `cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion is `action_required`, additional details should be provided on the site specified by `details_url`.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string | null;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check.
     */
    name: string;
    check_suite: {
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "queued" | "in_progress";
      conclusion: null;
      url: string;
      before: string | null;
      after: string | null;
      pull_requests: {
        url: string;
        id: number;
        number: number;
        head: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
        base: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
      }[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
  };
  requested_action?: {
    identifier?: string;
  } | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckRunRequestedActionEvent {
  action: "requested_action";
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The phase of the lifecycle that the check is currently in.
     */
    status: "queued" | "in_progress" | "completed";
    /**
     * The final conclusion of the check. Can be one of `success`, `failure`, `neutral`, `cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion is `action_required`, additional details should be provided on the site specified by `details_url`.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string | null;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check.
     */
    name: string;
    check_suite: {
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "queued" | "in_progress" | "completed";
      conclusion:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "timed_out"
        | "action_required"
        | "stale"
        | null;
      url: string;
      before: string | null;
      after: string | null;
      pull_requests: {
        url: string;
        id: number;
        number: number;
        head: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
        base: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
      }[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
  };
  requested_action?: {
    identifier?: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckRunRerequestedEvent {
  action: "rerequested";
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The phase of the lifecycle that the check is currently in.
     */
    status: "completed";
    /**
     * The final conclusion of the check. Can be one of `success`, `failure`, `neutral`, `cancelled`, `skipped`, `timed_out`, or `action_required`. When the conclusion is `action_required`, additional details should be provided on the site specified by `details_url`.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check.
     */
    name: string;
    check_suite: {
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "completed";
      conclusion:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "timed_out"
        | "action_required"
        | "stale";
      url: string;
      before: string | null;
      after: string | null;
      pull_requests: {
        url: string;
        id: number;
        number: number;
        head: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
        base: {
          ref: string;
          sha: string;
          repo: RepoRef;
        };
      }[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
  };
  requested_action?: {
    identifier?: string;
  } | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckSuiteCompletedEvent {
  action: "completed";
  check_suite: {
    id: number;
    node_id: string;
    head_branch: string | null;
    /**
     * The SHA of the head commit that is being checked.
     */
    head_sha: string;
    status: "requested" | "in_progress" | "completed" | "queued" | null;
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    url: string;
    before: string;
    after: string;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
    app: App;
    created_at: string;
    updated_at: string;
    latest_check_runs_count: number;
    check_runs_url: string;
    head_commit: SimpleCommit;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface SimpleCommit {
  id: string;
  tree_id: string;
  message: string;
  timestamp: string;
  author: Committer;
  committer: Committer;
}
/**
 * Metaproperties for Git author/committer information.
 */
export interface Committer {
  name: string;
  email: string;
  date?: string;
  username?: string;
}
export interface CheckSuiteRequestedEvent {
  action: "requested";
  check_suite: {
    id: number;
    node_id: string;
    head_branch: string | null;
    /**
     * The SHA of the head commit that is being checked.
     */
    head_sha: string;
    status: "requested" | "in_progress" | "completed" | "queued" | null;
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    url: string;
    before: string;
    after: string;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
    app: App;
    created_at: string;
    updated_at: string;
    latest_check_runs_count: number;
    check_runs_url: string;
    head_commit: SimpleCommit;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckSuiteRerequestedEvent {
  action: "rerequested";
  check_suite: {
    id: number;
    node_id: string;
    head_branch: string | null;
    /**
     * The SHA of the head commit that is being checked.
     */
    head_sha: string;
    status: "requested" | "in_progress" | "completed" | "queued" | null;
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    url: string;
    before: string;
    after: string;
    pull_requests: {
      url: string;
      id: number;
      number: number;
      head: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
      base: {
        ref: string;
        sha: string;
        repo: RepoRef;
      };
    }[];
    app: App;
    created_at: string;
    updated_at: string;
    latest_check_runs_count: number;
    check_runs_url: string;
    head_commit: SimpleCommit;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertAppearedInBranchEvent {
  action: "appeared_in_branch";
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: {
      /**
       * The full Git reference, formatted as `refs/heads/<branch name>`.
       */
      ref: string;
      /**
       * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
       */
      analysis_key: string;
      /**
       * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
       */
      environment: string;
      /**
       * State of a code scanning alert.
       */
      state: "open" | "dismissed" | "fixed";
    }[];
    /**
     * State of a code scanning alert.
     */
    state: "open" | "dismissed" | "fixed";
    dismissed_by: User | null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: string | null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: "false positive" | "won't fix" | "used in tests" | null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface GitHubOrg {
  login: "github";
  id: 9919;
  node_id: "MDEyOk9yZ2FuaXphdGlvbjk5MTk=";
  url: "https://api.github.com/orgs/github";
  repos_url: "https://api.github.com/orgs/github/repos";
  events_url: "https://api.github.com/orgs/github/events";
  hooks_url: "https://api.github.com/orgs/github/hooks";
  issues_url: "https://api.github.com/orgs/github/issues";
  members_url: "https://api.github.com/orgs/github/members{/member}";
  public_members_url: "https://api.github.com/orgs/github/public_members{/member}";
  avatar_url: "https://avatars.githubusercontent.com/u/9919?v=4";
  description: "How people build software.";
  name: "GitHub";
  company: null;
  blog: "https://github.com/about";
  location: "San Francisco, CA";
  email: null;
  twitter_username: null;
  is_verified: true;
  has_organization_projects: true;
  has_repository_projects: true;
  public_repos: number;
  public_gists: number;
  followers: number;
  following: number;
  html_url: "https://github.com/github";
  created_at: "2008-05-11T04:37:31Z";
  updated_at: string;
  type: "Organization";
}
export interface CodeScanningAlertClosedByUserEvent {
  action: "closed_by_user";
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: {
      /**
       * The full Git reference, formatted as `refs/heads/<branch name>`.
       */
      ref: string;
      /**
       * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
       */
      analysis_key: string;
      /**
       * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
       */
      environment: string;
      /**
       * State of a code scanning alert.
       */
      state: "dismissed";
    }[];
    /**
     * State of a code scanning alert.
     */
    state: "dismissed";
    dismissed_by: User;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: string;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: "false positive" | "won't fix" | "used in tests" | null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  commit_oid: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertCreatedEvent {
  action: "created";
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: {
      /**
       * The full Git reference, formatted as `refs/heads/<branch name>`.
       */
      ref: string;
      /**
       * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
       */
      analysis_key: string;
      /**
       * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
       */
      environment: string;
      /**
       * State of a code scanning alert.
       */
      state: "open" | "dismissed";
    }[];
    /**
     * State of a code scanning alert.
     */
    state: "open" | "dismissed";
    dismissed_by: null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertFixedEvent {
  action: "fixed";
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: {
      /**
       * The full Git reference, formatted as `refs/heads/<branch name>`.
       */
      ref: string;
      /**
       * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
       */
      analysis_key: string;
      /**
       * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
       */
      environment: string;
      /**
       * State of a code scanning alert.
       */
      state: "open" | "dismissed" | "fixed";
    }[];
    /**
     * State of a code scanning alert.
     */
    state: "fixed";
    dismissed_by: User | null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: string | null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: "false positive" | "won't fix" | "used in tests" | null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertReopenedEvent {
  action: "reopened";
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: {
      /**
       * The full Git reference, formatted as `refs/heads/<branch name>`.
       */
      ref: string;
      /**
       * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
       */
      analysis_key: string;
      /**
       * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
       */
      environment: string;
      /**
       * State of a code scanning alert.
       */
      state: "open";
    }[];
    /**
     * State of a code scanning alert.
     */
    state: "open" | "dismissed" | "fixed";
    dismissed_by: null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertReopenedByUserEvent {
  action: "reopened_by_user";
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: {
      /**
       * The full Git reference, formatted as `refs/heads/<branch name>`.
       */
      ref: string;
      /**
       * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
       */
      analysis_key: string;
      /**
       * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
       */
      environment: string;
      /**
       * State of a code scanning alert.
       */
      state: "open";
    }[];
    /**
     * State of a code scanning alert.
     */
    state: "open";
    dismissed_by: null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  commit_oid: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CommitCommentCreatedEvent {
  action: "created";
  comment: {
    url: string;
    html_url: string;
    id: number;
    node_id: string;
    user: User;
    position: number | null;
    line: number | null;
    path: string | null;
    commit_id: string;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ContentReferenceCreatedEvent {
  action: "created";
  content_reference: {
    id: number;
    node_id: string;
    reference: string;
  };
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
export interface CreateEvent {
  ref: string;
  ref_type: "tag" | "branch";
  master_branch: string;
  description: string | null;
  pusher_type: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeleteEvent {
  ref: string;
  ref_type: "tag" | "branch";
  pusher_type: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeployKeyCreatedEvent {
  action: "created";
  key: {
    id: number;
    key: string;
    url: string;
    title: string;
    verified: boolean;
    created_at: string;
    read_only: boolean;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeployKeyDeletedEvent {
  action: "deleted";
  key: {
    id: number;
    key: string;
    url: string;
    title: string;
    verified: boolean;
    created_at: string;
    read_only: boolean;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeploymentCreatedEvent {
  action: "created";
  deployment: {
    url: string;
    id: number;
    node_id: string;
    sha: string;
    ref: string;
    task: string;
    payload: {};
    original_environment: string;
    environment: string;
    description: null;
    creator: User;
    created_at: string;
    updated_at: string;
    statuses_url: string;
    repository_url: string;
    performed_via_github_app?: App | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeploymentStatusCreatedEvent {
  action: "created";
  deployment_status: {
    url: string;
    id: number;
    node_id: string;
    state: string;
    creator: User;
    description: string;
    environment: string;
    target_url: string;
    created_at: string;
    updated_at: string;
    deployment_url: string;
    repository_url: string;
    performed_via_github_app?: App | null;
  };
  deployment: {
    url: string;
    id: number;
    node_id: string;
    sha: string;
    ref: string;
    task: string;
    payload: {};
    original_environment: string;
    environment: string;
    description: null;
    creator: User;
    created_at: string;
    updated_at: string;
    statuses_url: string;
    repository_url: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ForkEvent {
  forkee: {
    id: number;
    node_id: string;
    name: string;
    full_name: string;
    private: boolean;
    owner: User;
    html_url: string;
    description: string | null;
    fork: true;
    url: string;
    forks_url: string;
    keys_url: string;
    collaborators_url: string;
    teams_url: string;
    hooks_url: string;
    issue_events_url: string;
    events_url: string;
    assignees_url: string;
    branches_url: string;
    tags_url: string;
    blobs_url: string;
    git_tags_url: string;
    git_refs_url: string;
    trees_url: string;
    statuses_url: string;
    languages_url: string;
    stargazers_url: string;
    contributors_url: string;
    subscribers_url: string;
    subscription_url: string;
    commits_url: string;
    git_commits_url: string;
    comments_url: string;
    issue_comment_url: string;
    contents_url: string;
    compare_url: string;
    merges_url: string;
    archive_url: string;
    downloads_url: string;
    issues_url: string;
    pulls_url: string;
    milestones_url: string;
    notifications_url: string;
    labels_url: string;
    releases_url: string;
    deployments_url: string;
    created_at: number | string;
    updated_at: string;
    pushed_at: number | string;
    git_url: string;
    ssh_url: string;
    clone_url: string;
    svn_url: string;
    homepage: string | null;
    size: number;
    stargazers_count: number;
    watchers_count: number;
    language: string | null;
    has_issues: boolean;
    has_projects: boolean;
    has_downloads: boolean;
    has_wiki: boolean;
    has_pages: boolean;
    forks_count: number;
    mirror_url: string | null;
    archived: boolean;
    disabled?: boolean;
    open_issues_count: number;
    license: License | string | null;
    forks: number;
    open_issues: number;
    watchers: number;
    stargazers?: number;
    default_branch: string;
    allow_squash_merge?: boolean;
    allow_merge_commit?: boolean;
    allow_rebase_merge?: boolean;
    delete_branch_on_merge?: boolean;
    master_branch?: string;
    permissions?: {
      pull: boolean;
      push: boolean;
      admin: boolean;
      maintain?: boolean;
      triage?: boolean;
    };
    public: boolean;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface GithubAppAuthorizationRevokedEvent {
  action: "revoked";
  sender: User;
}
export interface GollumEvent {
  pages: {
    page_name: string;
    title: string;
    summary: null;
    action: "created" | "edited";
    sha: string;
    html_url: string;
  }[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface InstallationCreatedEvent {
  action: "created";
  installation: Installation;
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
/**
 * Installation
 */
export interface Installation {
  /**
   * The ID of the installation.
   */
  id: number;
  account: User;
  /**
   * Describe whether all repositories have been selected or there's a selection involved
   */
  repository_selection: "all" | "selected";
  access_tokens_url: string;
  repositories_url: string;
  html_url: string;
  app_id: number;
  app_slug?: string;
  /**
   * The ID of the user or organization this token is being scoped to.
   */
  target_id: number;
  target_type: "User" | "Organization";
  permissions: {
    actions?: "read" | "write";
    administration?: "read" | "write";
    checks?: "read" | "write";
    contents?: "read" | "write";
    deployments?: "read" | "write";
    issues?: "read" | "write";
    organization_administration?: "read" | "write";
    pages?: "read" | "write";
    pull_requests?: "read" | "write";
    repository_hooks?: "read" | "write";
    repository_projects?: "read" | "write";
    statuses?: "read" | "write";
    metadata?: "read" | "write";
    vulnerability_alerts?: "read" | "write";
  };
  events: string[];
  created_at: string | number;
  updated_at: string | number;
  single_file_name: string | null;
  has_multiple_single_files?: boolean;
  single_file_paths?: string[];
  suspended_by?: string | null;
  suspended_at?: string | null;
}
export interface InstallationDeletedEvent {
  action: "deleted";
  installation: Installation;
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationNewPermissionsAcceptedEvent {
  action: "new_permissions_accepted";
  installation: Installation;
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationSuspendEvent {
  action: "suspend";
  installation: Installation;
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationUnsuspendEvent {
  action: "unsuspend";
  installation: Installation;
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationRepositoriesAddedEvent {
  action: "added";
  installation: Installation;
  /**
   * Describe whether all repositories have been selected or there's a selection involved
   */
  repository_selection: "all" | "selected";
  repositories_added: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  repositories_removed: [];
  sender: User;
}
export interface InstallationRepositoriesRemovedEvent {
  action: "removed";
  installation: Installation;
  /**
   * Describe whether all repositories have been selected or there's a selection involved
   */
  repository_selection: "all" | "selected";
  repositories_added: [];
  repositories_removed: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  sender: User;
}
export interface IssueCommentCreatedEvent {
  action: "created";
  issue: Issue & {
    assignee: User | null;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: "open" | "closed";
    closed_at: null;
    locked: boolean;
    labels: Label[];
    pull_request?: {
      url: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
    };
  };
  comment: {
    /**
     * URL for the issue comment
     */
    url: string;
    html_url: string;
    issue_url: string;
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    user: User;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * Contents of the issue comment
     */
    body: string;
    performed_via_github_app?: App | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Issue {
  /**
   * URL for the issue
   */
  url: string;
  repository_url: string;
  labels_url: string;
  comments_url: string;
  events_url: string;
  html_url: string;
  id: number;
  node_id: string;
  number: number;
  /**
   * Title of the issue
   */
  title: string;
  user: User;
  labels?: Label[];
  /**
   * State of the issue; either 'open' or 'closed'
   */
  state?: "open" | "closed";
  locked?: boolean;
  assignee?: User | null;
  assignees: User[];
  milestone: Milestone | null;
  comments: number;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  author_association: AuthorAssociation;
  active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
  performed_via_github_app?: App | null;
  pull_request?: {
    url?: string;
    html_url?: string;
    diff_url?: string;
    patch_url?: string;
  };
  /**
   * Contents of the issue
   */
  body: string;
}
/**
 * Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
 */
export interface Label {
  id: number;
  node_id: string;
  /**
   * URL for the label
   */
  url: string;
  /**
   * The name of the label.
   */
  name: string;
  description: string | null;
  /**
   * 6-character hex code, without the leading #, identifying the color
   */
  color: string;
  default: boolean;
}
/**
 * A collection of related issues and pull requests.
 */
export interface Milestone {
  url: string;
  html_url: string;
  labels_url: string;
  id: number;
  node_id: string;
  /**
   * The number of the milestone.
   */
  number: number;
  /**
   * The title of the milestone.
   */
  title: string;
  description: string | null;
  creator: User;
  open_issues: number;
  closed_issues: number;
  /**
   * The state of the milestone.
   */
  state: "open" | "closed";
  created_at: string;
  updated_at: string;
  due_on: string | null;
  closed_at: string | null;
}
export interface IssueCommentDeletedEvent {
  action: "deleted";
  issue: Issue & {
    assignee: User | null;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: "open" | "closed";
    closed_at: null;
    locked: boolean;
    labels: Label[];
    pull_request?: {
      url: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
    };
  };
  comment: {
    /**
     * URL for the issue comment
     */
    url: string;
    html_url: string;
    issue_url: string;
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    user: User;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * Contents of the issue comment
     */
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssueCommentEditedEvent {
  action: "edited";
  changes: {
    body?: {
      from: string;
    };
  };
  issue: Issue & {
    assignee: User | null;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: "open" | "closed";
    closed_at: null;
    locked: boolean;
    labels: Label[];
    pull_request?: {
      url: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
    };
  };
  comment: {
    /**
     * URL for the issue comment
     */
    url: string;
    html_url: string;
    issue_url: string;
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    user: User;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * Contents of the issue comment
     */
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesAssignedEvent {
  action: "assigned";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesClosedEvent {
  action: "closed";
  issue: Issue & {
    state: "closed";
    closed_at: string;
  };
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesDeletedEvent {
  action: "deleted";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesDemilestonedEvent {
  action: "demilestoned";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesEditedEvent {
  action: "edited";
  issue: Issue;
  label?: Label;
  changes: {
    body?: {
      from: string;
    };
    title?: {
      from: string;
    };
  };
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesLabeledEvent {
  action: "labeled";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesLockedEvent {
  action: "locked";
  issue: Issue & {
    locked: true;
    active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam";
  };
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesMilestonedEvent {
  action: "milestoned";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesOpenedEvent {
  action: "opened";
  issue: Issue & {
    state: "open";
    closed_at: null;
  };
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesPinnedEvent {
  action: "pinned";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesReopenedEvent {
  action: "reopened";
  issue: Issue & {
    state: "open";
  };
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesTransferredEvent {
  action: "transferred";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnassignedEvent {
  action: "unassigned";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnlabeledEvent {
  action: "unlabeled";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnlockedEvent {
  action: "unlocked";
  issue: Issue & {
    locked: false;
    active_lock_reason: null;
  };
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnpinnedEvent {
  action: "unpinned";
  issue: Issue;
  label?: Label;
  assignee?: User | null;
  assignees?: User[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface LabelCreatedEvent {
  action: "created";
  label: Label;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface LabelDeletedEvent {
  action: "deleted";
  label: Label;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface LabelEditedEvent {
  action: "edited";
  label: Label;
  changes?: {
    color?: {
      from: string;
    };
    name?: {
      from: string;
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MarketplacePurchaseCancelledEvent {
  action: "cancelled";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchase {
  account: {
    type: string;
    id: number;
    login: string;
    organization_billing_email: string;
  };
  billing_cycle: string;
  unit_count: number;
  on_free_trial: boolean;
  free_trial_ends_on: null;
  next_billing_date?: string;
  plan: {
    id: number;
    name: string;
    description: string;
    monthly_price_in_cents: number;
    yearly_price_in_cents: number;
    price_model: string;
    has_free_trial: boolean;
    unit_name: string | null;
    bullets: string[];
  };
}
export interface MarketplacePurchaseChangedEvent {
  action: "changed";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchasePendingChangeEvent {
  action: "pending_change";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchasePendingChangeCancelledEvent {
  action: "pending_change_cancelled";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchasePurchasedEvent {
  action: "purchased";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MemberAddedEvent {
  action: "added";
  member: User;
  repository: Repository;
  installation?: InstallationLite;
  sender: User;
}
export interface MemberEditedEvent {
  action: "edited";
  member: User;
  changes: {
    old_permission: {
      from: string;
    };
  };
  repository: Repository;
  installation?: InstallationLite;
  sender: User;
}
export interface MemberRemovedEvent {
  action: "removed";
  member: User;
  repository: Repository;
  installation?: InstallationLite;
  sender: User;
}
export interface MembershipAddedEvent {
  action: "added";
  scope: "team";
  member: User;
  sender: User;
  team: Team;
  organization: Organization;
  installation?: InstallationLite;
}
/**
 * Groups of organization members that gives permissions on specified repositories.
 */
export interface Team {
  /**
   * Name of the team
   */
  name: string;
  /**
   * Unique identifier of the team
   */
  id: number;
  node_id: string;
  slug: string;
  /**
   * Description of the team
   */
  description: string | null;
  privacy: "open" | "closed" | "secret";
  /**
   * URL for the team
   */
  url: string;
  html_url: string;
  members_url: string;
  repositories_url: string;
  /**
   * Permission that the team will have for its repositories
   */
  permission: string;
  parent?: {
    /**
     * Name of the team
     */
    name: string;
    /**
     * Unique identifier of the team
     */
    id: number;
    node_id: string;
    slug: string;
    /**
     * Description of the team
     */
    description: string | null;
    privacy: "open" | "closed" | "secret";
    /**
     * URL for the team
     */
    url: string;
    html_url: string;
    members_url: string;
    repositories_url: string;
    /**
     * Permission that the team will have for its repositories
     */
    permission: string;
  } | null;
}
export interface MembershipRemovedEvent {
  action: "removed";
  scope: "team";
  member: User;
  sender: User;
  team: Team;
  organization: Organization;
  installation?: InstallationLite;
}
export interface MetaDeletedEvent {
  action: "deleted";
  hook_id: number;
  hook: {
    type: string;
    id: number;
    name: string;
    active: boolean;
    events: string[];
    config: {
      content_type: string;
      insecure_ssl: string;
      url: string;
    };
    updated_at: string;
    created_at: string;
  };
  repository: Repository;
  sender: User;
}
export interface MilestoneClosedEvent {
  action: "closed";
  milestone: Milestone & {
    state: "closed";
    closed_at: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneCreatedEvent {
  action: "created";
  milestone: Milestone & {
    state: "open";
    closed_at: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneDeletedEvent {
  action: "deleted";
  milestone: Milestone;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneEditedEvent {
  action: "edited";
  changes: {
    description?: {
      from: string;
    };
    due_on?: {
      from: string;
    };
    title?: {
      from: string;
    };
  };
  milestone: Milestone;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneOpenedEvent {
  action: "opened";
  milestone: Milestone & {
    state: "open";
    closed_at: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface OrgBlockBlockedEvent {
  action: "blocked";
  blocked_user: User;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrgBlockUnblockedEvent {
  action: "unblocked";
  blocked_user: User;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationDeletedEvent {
  action: "deleted";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface Membership {
  url: string;
  state: string;
  role: string;
  organization_url: string;
  user: User;
}
export interface OrganizationMemberAddedEvent {
  action: "member_added";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationMemberInvitedEvent {
  action: "member_invited";
  invitation: {};
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationMemberRemovedEvent {
  action: "member_removed";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationRenamedEvent {
  action: "renamed";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface PackagePublishedEvent {
  action: "published";
  package: {
    id: number;
    name: string;
    package_type: string;
    html_url: string;
    created_at: string;
    updated_at: string;
    owner: User;
    package_version: {
      id: number;
      version: string;
      summary: string;
      body: string;
      body_html: string;
      release: {
        url: string;
        html_url: string;
        id: number;
        tag_name: string;
        target_commitish: string;
        name: string;
        draft: boolean;
        author: User;
        prerelease: boolean;
        created_at: string;
        published_at: string;
      };
      manifest: string;
      html_url: string;
      tag_name: string;
      target_commitish: string;
      target_oid: string;
      draft: boolean;
      prerelease: boolean;
      created_at: string;
      updated_at: string;
      metadata: unknown[];
      package_files: {
        download_url: string;
        id: number;
        name: string;
        sha256: string;
        sha1: string;
        md5: string;
        content_type: string;
        state: string;
        size: number;
        created_at: string;
        updated_at: string;
      }[];
      author: User;
      installation_command: string;
    };
    registry: {
      about_url: string;
      name: string;
      type: string;
      url: string;
      vendor: string;
    };
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface PackageUpdatedEvent {
  action: "updated";
  package: {
    id: number;
    name: string;
    package_type: string;
    html_url: string;
    created_at: string;
    updated_at: string;
    owner: User;
    package_version: {
      id: number;
      version: string;
      summary: string;
      body: string;
      body_html: string;
      release: {
        url: string;
        html_url: string;
        id: number;
        tag_name: string;
        target_commitish: string;
        name: string;
        draft: boolean;
        author: User;
        prerelease: boolean;
        created_at: string;
        published_at: string;
      };
      manifest: string;
      html_url: string;
      tag_name: string;
      target_commitish: string;
      target_oid: string;
      draft: boolean;
      prerelease: boolean;
      created_at: string;
      updated_at: string;
      metadata: unknown[];
      package_files: {
        download_url: string;
        id: number;
        name: string;
        sha256: string;
        sha1: string;
        md5: string;
        content_type: string;
        state: string;
        size: number;
        created_at: string;
        updated_at: string;
      }[];
      author: User;
      installation_command: string;
    };
    registry: {
      about_url: string;
      name: string;
      type: string;
      url: string;
      vendor: string;
    };
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
/**
 * Page Build
 */
export interface PageBuildEvent {
  id: number;
  build: {
    url: string;
    status: string;
    error: {
      message: string | null;
    };
    pusher: User;
    commit: string;
    duration: number;
    created_at: string;
    updated_at: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface PingEvent {
  zen: string;
  hook_id: number;
  hook: {
    type: string;
    id: number;
    name: string;
    active: boolean;
    events: string[];
    config: {
      content_type: string;
      secret?: string;
      url: string;
      insecure_ssl: string;
    };
    updated_at: string;
    created_at: string;
    url: string;
    test_url?: string;
    ping_url: string;
    last_response?: {
      code: null;
      status: string;
      message: null;
    };
  };
  repository?: Repository;
  sender?: User;
  organization?: Organization;
}
export interface ProjectClosedEvent {
  action: "closed";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Project {
  owner_url: string;
  url: string;
  html_url: string;
  columns_url: string;
  id: number;
  node_id: string;
  /**
   * Name of the project
   */
  name: string;
  /**
   * Body of the project
   */
  body: string | null;
  number: number;
  /**
   * State of the project; either 'open' or 'closed'
   */
  state: "open" | "closed";
  creator: User;
  created_at: string;
  updated_at: string;
}
export interface ProjectCreatedEvent {
  action: "created";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectDeletedEvent {
  action: "deleted";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectEditedEvent {
  action: "edited";
  changes: {
    name?: {
      from: string;
    };
    body?: {
      from: string;
    };
  };
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectReopenedEvent {
  action: "reopened";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectCardConvertedEvent {
  action: "converted";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCard {
  url: string;
  project_url: string;
  column_url: string;
  column_id: number;
  /**
   * The project card's ID
   */
  id: number;
  node_id: string;
  note: string;
  /**
   * Whether or not the card is archived
   */
  archived: boolean;
  creator: User;
  created_at: string;
  updated_at: string;
  content_url: string;
}
export interface ProjectCardCreatedEvent {
  action: "created";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCardDeletedEvent {
  action: "deleted";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCardEditedEvent {
  action: "edited";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCardMovedEvent {
  action: "moved";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectColumnCreatedEvent {
  action: "created";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectColumn {
  url: string;
  project_url: string;
  cards_url: string;
  /**
   * The unique identifier of the project column
   */
  id: number;
  node_id: string;
  /**
   * Name of the project column
   */
  name: string;
  created_at: string;
  updated_at: string;
}
export interface ProjectColumnDeletedEvent {
  action: "deleted";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectColumnEditedEvent {
  action: "edited";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectColumnMovedEvent {
  action: "moved";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface PublicEvent {
  repository: Repository & {
    private: false;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface PullRequestAssignedEvent {
  action: "assigned";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequest {
  url: string;
  id: number;
  node_id: string;
  html_url: string;
  diff_url: string;
  patch_url: string;
  issue_url: string;
  /**
   * Number uniquely identifying the pull request within its repository.
   */
  number: number;
  /**
   * State of this Pull Request. Either `open` or `closed`.
   */
  state: "open" | "closed";
  locked: boolean;
  /**
   * The title of the pull request.
   */
  title: string;
  user: User;
  body: string;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  merged_at: string | null;
  merge_commit_sha: string | null;
  assignee: User | null;
  assignees: User[];
  requested_reviewers: (User | Team)[];
  requested_teams: Team[];
  labels: Label[];
  milestone: Milestone | null;
  commits_url: string;
  review_comments_url: string;
  review_comment_url: string;
  comments_url: string;
  statuses_url: string;
  head: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  base: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  _links: {
    self: Link;
    html: Link;
    issue: Link;
    comments: Link;
    review_comments: Link;
    review_comment: Link;
    commits: Link;
    statuses: Link;
  };
  author_association: AuthorAssociation;
  active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
  /**
   * Indicates whether or not the pull request is a draft.
   */
  draft: boolean;
  merged: boolean | null;
  mergeable: boolean | null;
  rebaseable: boolean | null;
  mergeable_state: string;
  merged_by: User | null;
  comments: number;
  review_comments: number;
  /**
   * Indicates whether maintainers can modify the pull request.
   */
  maintainer_can_modify: boolean;
  commits: number;
  additions: number;
  deletions: number;
  changed_files: number;
}
export interface Link {
  href: string;
}
export interface PullRequestAutoMergeDisabledEvent {
  action: "auto_merge_disabled";
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestAutoMergeEnabledEvent {
  action: "auto_merge_enabled";
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestClosedEvent {
  action: "closed";
  number: number;
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    /**
     * Number uniquely identifying the pull request within its repository.
     */
    number: number;
    /**
     * State of this Pull Request. Either `open` or `closed`.
     */
    state: "closed";
    locked: boolean;
    /**
     * The title of the pull request.
     */
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
    active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
    /**
     * Indicates whether or not the pull request is a draft.
     */
    draft: boolean;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable: boolean | null;
    mergeable_state: string;
    merged_by: User | null;
    comments: number;
    review_comments: number;
    /**
     * Indicates whether maintainers can modify the pull request.
     */
    maintainer_can_modify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changed_files: number;
  };
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestConvertedToDraftEvent {
  action: "converted_to_draft";
  number: number;
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    /**
     * Number uniquely identifying the pull request within its repository.
     */
    number: number;
    /**
     * State of this Pull Request. Either `open` or `closed`.
     */
    state: "open" | "closed";
    locked: boolean;
    /**
     * The title of the pull request.
     */
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
    active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
    /**
     * Indicates whether or not the pull request is a draft.
     */
    draft: true;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable: boolean | null;
    mergeable_state: string;
    merged_by: null;
    comments: number;
    review_comments: number;
    /**
     * Indicates whether maintainers can modify the pull request.
     */
    maintainer_can_modify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changed_files: number;
  };
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestEditedEvent {
  action: "edited";
  number: number;
  changes: {
    body?: {
      from: string;
    };
    title?: {
      from: string;
    };
  };
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestLabeledEvent {
  action: "labeled";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestLockedEvent {
  action: "locked";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestOpenedEvent {
  action: "opened";
  number: number;
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
    active_lock_reason: null;
    draft: boolean;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable: boolean | null;
    mergeable_state: string;
    merged_by: null;
    comments: number;
    review_comments: number;
    maintainer_can_modify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changed_files: number;
  };
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReadyForReviewEvent {
  action: "ready_for_review";
  number: number;
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
    active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
    draft: false;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable: boolean | null;
    mergeable_state: string;
    merged_by: null;
    comments: number;
    review_comments: number;
    maintainer_can_modify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changed_files: number;
  };
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReopenedEvent {
  action: "reopened";
  number: number;
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
    active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
    draft: boolean;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable: boolean | null;
    mergeable_state: string;
    merged_by: null;
    comments: number;
    review_comments: number;
    maintainer_can_modify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changed_files: number;
  };
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewRequestRemovedEvent {
  action: "review_request_removed";
  number: number;
  pull_request: PullRequest;
  requested_reviewer: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewRequestedEvent {
  action: "review_requested";
  number: number;
  pull_request: PullRequest;
  requested_reviewer: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestSynchronizeEvent {
  action: "synchronize";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestUnassignedEvent {
  action: "unassigned";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestUnlabeledEvent {
  action: "unlabeled";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestUnlockedEvent {
  action: "unlocked";
  number: number;
  pull_request: PullRequest;
  label?: Label;
  assignee?: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewDismissedEvent {
  action: "dismissed";
  review: {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: User;
    /**
     * The text of the review.
     */
    body: string | null;
    /**
     * A commit SHA for the review.
     */
    commit_id: string;
    submitted_at: string;
    state: "dismissed";
    html_url: string;
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      html: Link;
      pull_request: Link;
    };
  };
  pull_request: SimplePullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface SimplePullRequest {
  url: string;
  id: number;
  node_id: string;
  html_url: string;
  diff_url: string;
  patch_url: string;
  issue_url: string;
  number: number;
  state: "open" | "closed";
  locked: boolean;
  title: string;
  user: User;
  body: string;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  merged_at: string | null;
  merge_commit_sha: string | null;
  assignee: User | null;
  assignees: User[];
  requested_reviewers: (User | Team)[];
  requested_teams: Team[];
  labels: Label[];
  milestone: Milestone | null;
  draft: boolean;
  commits_url: string;
  review_comments_url: string;
  review_comment_url: string;
  comments_url: string;
  statuses_url: string;
  head: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  base: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  _links: {
    self: Link;
    html: Link;
    issue: Link;
    comments: Link;
    review_comments: Link;
    review_comment: Link;
    commits: Link;
    statuses: Link;
  };
  author_association: AuthorAssociation;
  active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
}
export interface PullRequestReviewEditedEvent {
  action: "edited";
  changes: {
    body: {
      from: string;
    };
  };
  review: {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: User;
    /**
     * The text of the review.
     */
    body: string | null;
    /**
     * A commit SHA for the review.
     */
    commit_id: string;
    submitted_at: string;
    state: string;
    html_url: string;
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      html: Link;
      pull_request: Link;
    };
  };
  pull_request: SimplePullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewSubmittedEvent {
  action: "submitted";
  review: {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: User;
    /**
     * The text of the review.
     */
    body: string | null;
    /**
     * A commit SHA for the review.
     */
    commit_id: string;
    submitted_at: string;
    state: string;
    html_url: string;
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      html: Link;
      pull_request: Link;
    };
  };
  pull_request: SimplePullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewCommentCreatedEvent {
  action: "created";
  comment: {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number;
    /**
     * The index of the original line in the diff to which the comment applies.
     */
    original_position: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    user: User;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      self: Link;
      html: Link;
      pull_request: Link;
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: ("LEFT" | "RIGHT") | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: "LEFT" | "RIGHT";
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
  };
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open" | "closed";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewCommentDeletedEvent {
  action: "deleted";
  comment: {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number;
    /**
     * The index of the original line in the diff to which the comment applies.
     */
    original_position: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    user: User;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      self: Link;
      html: Link;
      pull_request: Link;
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: ("LEFT" | "RIGHT") | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: "LEFT" | "RIGHT";
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
  };
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open" | "closed";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewCommentEditedEvent {
  action: "edited";
  changes: {
    body?: {
      from: string;
    };
  };
  comment: {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number;
    /**
     * The index of the original line in the diff to which the comment applies.
     */
    original_position: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    user: User;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      self: Link;
      html: Link;
      pull_request: Link;
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: ("LEFT" | "RIGHT") | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: "LEFT" | "RIGHT";
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
  };
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open" | "closed";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PushEvent {
  ref: string;
  before: string;
  after: string;
  created: boolean;
  deleted: boolean;
  forced: boolean;
  base_ref: null;
  compare: string;
  commits: Commit[];
  head_commit: Commit | null;
  repository: Repository;
  pusher: Committer;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Commit {
  id: string;
  tree_id: string;
  distinct: boolean;
  message: string;
  timestamp: string;
  url: string;
  author: Committer & {
    username: string;
  };
  committer: Committer & {
    username: string;
  };
  added: string[];
  removed: string[];
  modified: string[];
}
export interface ReleaseCreatedEvent {
  action: "created";
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
/**
 * Data related to a release.
 */
export interface ReleaseAsset {
  url: string;
  browser_download_url: string;
  id: number;
  node_id: string;
  /**
   * The file name of the asset.
   */
  name: string;
  label: string;
  /**
   * State of the release asset.
   */
  state: "uploaded";
  content_type: string;
  size: number;
  download_count: number;
  created_at: string;
  updated_at: string;
  uploader?: User;
}
export interface ReleaseDeletedEvent {
  action: "deleted";
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleaseEditedEvent {
  action: "edited";
  changes: {
    body?: {
      from: string;
    };
    name?: {
      from: string;
    };
  };
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleasePrereleasedEvent {
  action: "prereleased";
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: true;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleasePublishedEvent {
  action: "published";
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleaseReleasedEvent {
  action: "released";
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleaseUnpublishedEvent {
  action: "unpublished";
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryArchivedEvent {
  action: "archived";
  repository: Repository & {
    /**
     * Whether the repository is archived.
     */
    archived: true;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryCreatedEvent {
  action: "created";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryDeletedEvent {
  action: "deleted";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryEditedEvent {
  action: "edited";
  changes: {
    description?: {
      from: string;
    };
    default_branch?: {
      from: string;
    };
    homepage?: {
      from: string;
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryPrivatizedEvent {
  action: "privatized";
  repository: Repository & {
    /**
     * Whether the repository is private or public.
     */
    private: true;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryPublicizedEvent {
  action: "publicized";
  repository: Repository & {
    /**
     * Whether the repository is private or public.
     */
    private: false;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryRenamedEvent {
  action: "renamed";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryTransferredEvent {
  action: "transferred";
  changes: {
    owner: {
      from: {
        user?: User;
      };
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryUnarchivedEvent {
  action: "unarchived";
  repository: Repository & {
    /**
     * Whether the repository is archived.
     */
    archived: false;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryDispatchOnDemandTestEvent {
  action: "on-demand-test";
  branch: string;
  client_payload: {
    [k: string]: unknown;
  };
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
export interface RepositoryImportEvent {
  status: "success" | "cancelled" | "failure";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryVulnerabilityAlertCreateEvent {
  action: "create";
  alert: {
    id: number;
    affected_range: string;
    affected_package_name: string;
    dismisser?: User;
    dismiss_reason?: string;
    dismissed_at?: string;
    ghsa_id?: string;
    external_reference: string;
    external_identifier: string;
    fixed_in: string;
    created_at?: string;
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface RepositoryVulnerabilityAlertDismissEvent {
  action: "dismiss";
  alert: {
    id: number;
    affected_range: string;
    affected_package_name: string;
    dismisser: User;
    dismiss_reason: string;
    dismissed_at: string;
    ghsa_id?: string;
    external_reference: string;
    external_identifier: string;
    fixed_in: string;
    created_at?: string;
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface RepositoryVulnerabilityAlertResolveEvent {
  action: "resolve";
  alert: {
    id: number;
    affected_range: string;
    affected_package_name: string;
    dismisser?: User;
    dismiss_reason?: string;
    dismissed_at?: string;
    ghsa_id?: string;
    external_reference: string;
    external_identifier: string;
    fixed_in: string;
    created_at?: string;
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface SecretScanningAlertCreatedEvent {
  action: "created";
  alert: {
    number: number;
    secret_type: string;
    resolution: null;
    resolved_by: null;
    resolved_at: null;
  };
  repository: Repository;
  organization?: Organization;
  installation?: InstallationLite;
  sender: User;
}
export interface SecretScanningAlertReopenedEvent {
  action: "reopened";
  alert: {
    number: number;
    secret_type: string;
    resolution: null;
    resolved_by: null;
    resolved_at: null;
  };
  repository: Repository;
  organization?: Organization;
  installation?: InstallationLite;
  sender: User;
}
export interface SecretScanningAlertResolvedEvent {
  action: "resolved";
  alert: {
    number: number;
    secret_type: string;
    resolution: "false_positive" | "wontfix" | "revoked" | "used_in_tests";
    resolved_by: User;
    resolved_at: string;
  };
  repository: Repository;
  organization?: Organization;
  installation?: InstallationLite;
  sender: User;
}
export interface SecurityAdvisoryPerformedEvent {
  action: "performed";
  security_advisory: {
    ghsa_id: string;
    summary: string;
    description: string;
    severity: string;
    identifiers: {
      value: string;
      type: string;
    }[];
    references: {
      url: string;
    }[];
    published_at: string;
    updated_at: string;
    withdrawn_at: string | null;
    vulnerabilities: {
      package: {
        ecosystem: string;
        name: string;
      };
      severity: string;
      vulnerable_version_range: string;
      first_patched_version: {
        identifier: string;
      } | null;
    }[];
  };
}
export interface SecurityAdvisoryPublishedEvent {
  action: "published";
  security_advisory: {
    ghsa_id: string;
    summary: string;
    description: string;
    severity: string;
    identifiers: {
      value: string;
      type: string;
    }[];
    references: {
      url: string;
    }[];
    published_at: string;
    updated_at: string;
    withdrawn_at: string | null;
    vulnerabilities: {
      package: {
        ecosystem: string;
        name: string;
      };
      severity: string;
      vulnerable_version_range: string;
      first_patched_version: {
        identifier: string;
      } | null;
    }[];
  };
}
export interface SecurityAdvisoryUpdatedEvent {
  action: "updated";
  security_advisory: {
    ghsa_id: string;
    summary: string;
    description: string;
    severity: string;
    identifiers: {
      value: string;
      type: string;
    }[];
    references: {
      url: string;
    }[];
    published_at: string;
    updated_at: string;
    withdrawn_at: string | null;
    vulnerabilities: {
      package: {
        ecosystem: string;
        name: string;
      };
      severity: string;
      vulnerable_version_range: string;
      first_patched_version: {
        identifier: string;
      } | null;
    }[];
  };
}
export interface SponsorshipCancelledEvent {
  action: "cancelled";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  sender: User;
}
export interface SponsorshipTier {
  node_id: string;
  created_at: string;
  description: string;
  monthly_price_in_cents: number;
  monthly_price_in_dollars: number;
  name: string;
}
export interface SponsorshipCreatedEvent {
  action: "created";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  sender: User;
}
export interface SponsorshipEditedEvent {
  action: "edited";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  changes: {
    privacy_level?: {
      from: string;
    };
  };
  sender: User;
}
export interface SponsorshipPendingCancellationEvent {
  action: "pending_cancellation";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  effective_date?: string;
  sender: User;
}
export interface SponsorshipPendingTierChangeEvent {
  action: "pending_tier_change";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  effective_date?: string;
  changes: {
    tier: {
      from: SponsorshipTier;
    };
  };
  sender: User;
}
export interface SponsorshipTierChangedEvent {
  action: "tier_changed";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  changes: {
    tier: {
      from: SponsorshipTier;
    };
  };
  sender: User;
}
export interface StarCreatedEvent {
  action: "created";
  starred_at: string;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface StarDeletedEvent {
  action: "deleted";
  starred_at: null;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface StatusEvent {
  id: number;
  sha: string;
  name: string;
  avatar_url?: string | null;
  target_url: string | null;
  context: string;
  description: string | null;
  state: "pending" | "success" | "failure" | "error";
  commit: {
    sha: string;
    node_id: string;
    commit: {
      author: Committer & {
        date: string;
      };
      committer: Committer & {
        date: string;
      };
      message: string;
      tree: {
        sha: string;
        url: string;
      };
      url: string;
      comment_count: number;
      verification: {
        verified: boolean;
        reason:
          | "expired_key"
          | "not_signing_key"
          | "gpgverify_error"
          | "gpgverify_unavailable"
          | "unsigned"
          | "unknown_signature_type"
          | "no_user"
          | "unverified_email"
          | "bad_email"
          | "unknown_key"
          | "malformed_signature"
          | "invalid"
          | "valid";
        signature: string | null;
        payload: string | null;
      };
    };
    url: string;
    html_url: string;
    comments_url: string;
    author: User | null;
    committer: User | null;
    parents: {
      sha: string;
      url: string;
      html_url: string;
    }[];
  };
  branches: {
    name: string;
    commit: {
      sha: string;
      url: string;
    };
    protected: boolean;
  }[];
  created_at: string;
  updated_at: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface TeamAddedToRepositoryEvent {
  action: "added_to_repository";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamCreatedEvent {
  action: "created";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamDeletedEvent {
  action: "deleted";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamEditedEvent {
  action: "edited";
  changes: {
    description?: {
      from: string;
    };
    name?: {
      from: string;
    };
    privacy?: {
      from: string;
    };
    repository?: {
      permissions: {
        from: {
          admin?: boolean;
          pull?: boolean;
          push?: boolean;
        };
      };
    };
  };
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamRemovedFromRepositoryEvent {
  action: "removed_from_repository";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamAddEvent {
  team: Team;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface WatchStartedEvent {
  action: "started";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface WorkflowDispatchEvent {
  inputs: {
    [k: string]: unknown;
  };
  ref: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
  workflow: string;
}
export interface WorkflowRunCompletedEvent {
  action: "completed";
  organization?: Organization;
  repository: Repository;
  sender: User;
  workflow: Workflow;
  workflow_run: WorkflowRun;
  installation?: InstallationLite;
}
export interface Workflow {
  badge_url: string;
  created_at: string;
  html_url: string;
  id: number;
  name: string;
  node_id: string;
  path: string;
  state: string;
  updated_at: string;
  url: string;
}
export interface WorkflowRun {
  artifacts_url: string;
  cancel_url: string;
  check_suite_url: string;
  conclusion: string | null;
  created_at: string;
  event: string;
  head_branch: string;
  head_commit: SimpleCommit;
  head_repository: {
    archive_url: string;
    assignees_url: string;
    blobs_url: string;
    branches_url: string;
    collaborators_url: string;
    comments_url: string;
    commits_url: string;
    compare_url: string;
    contents_url: string;
    contributors_url: string;
    deployments_url: string;
    description: string;
    downloads_url: string;
    events_url: string;
    fork: boolean;
    forks_url: string;
    full_name: string;
    git_commits_url: string;
    git_refs_url: string;
    git_tags_url: string;
    hooks_url: string;
    html_url: string;
    id: number;
    issue_comment_url: string;
    issue_events_url: string;
    issues_url: string;
    keys_url: string;
    labels_url: string;
    languages_url: string;
    merges_url: string;
    milestones_url: string;
    name: string;
    node_id: string;
    notifications_url: string;
    owner: User;
    private: boolean;
    pulls_url: string;
    releases_url: string;
    stargazers_url: string;
    statuses_url: string;
    subscribers_url: string;
    subscription_url: string;
    tags_url: string;
    teams_url: string;
    trees_url: string;
    url: string;
  };
  head_sha: string;
  html_url: string;
  id: number;
  jobs_url: string;
  logs_url: string;
  node_id: string;
  pull_requests: unknown[];
  repository: {
    archive_url: string;
    assignees_url: string;
    blobs_url: string;
    branches_url: string;
    collaborators_url: string;
    comments_url: string;
    commits_url: string;
    compare_url: string;
    contents_url: string;
    contributors_url: string;
    deployments_url: string;
    description: string;
    downloads_url: string;
    events_url: string;
    fork: boolean;
    forks_url: string;
    full_name: string;
    git_commits_url: string;
    git_refs_url: string;
    git_tags_url: string;
    hooks_url: string;
    html_url: string;
    /**
     * Unique identifier of the repository
     */
    id: number;
    issue_comment_url: string;
    issue_events_url: string;
    issues_url: string;
    keys_url: string;
    labels_url: string;
    languages_url: string;
    merges_url: string;
    milestones_url: string;
    /**
     * The name of the repository.
     */
    name: string;
    node_id: string;
    notifications_url: string;
    owner: User;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
    pulls_url: string;
    releases_url: string;
    stargazers_url: string;
    statuses_url: string;
    subscribers_url: string;
    subscription_url: string;
    tags_url: string;
    teams_url: string;
    trees_url: string;
    url: string;
  };
  rerun_url: string;
  run_number: number;
  status: string;
  updated_at: string;
  url: string;
  workflow_id: number;
  workflow_url: string;
}
export interface WorkflowRunRequestedEvent {
  action: "requested";
  organization?: Organization;
  repository: Repository;
  sender: User;
  workflow: Workflow;
  workflow_run: WorkflowRun;
  installation?: InstallationLite;
}

export interface EventPayloadMap {
  check_run: CheckRunEvent;
  check_suite: CheckSuiteEvent;
  code_scanning_alert: CodeScanningAlertEvent;
  commit_comment: CommitCommentEvent;
  content_reference: ContentReferenceEvent;
  create: CreateEvent;
  delete: DeleteEvent;
  deploy_key: DeployKeyEvent;
  deployment: DeploymentEvent;
  deployment_status: DeploymentStatusEvent;
  fork: ForkEvent;
  github_app_authorization: GithubAppAuthorizationEvent;
  gollum: GollumEvent;
  installation: InstallationEvent;
  installation_repositories: InstallationRepositoriesEvent;
  issue_comment: IssueCommentEvent;
  issues: IssuesEvent;
  label: LabelEvent;
  marketplace_purchase: MarketplacePurchaseEvent;
  member: MemberEvent;
  membership: MembershipEvent;
  meta: MetaEvent;
  milestone: MilestoneEvent;
  org_block: OrgBlockEvent;
  organization: OrganizationEvent;
  package: PackageEvent;
  page_build: PageBuildEvent;
  ping: PingEvent;
  project: ProjectEvent;
  project_card: ProjectCardEvent;
  project_column: ProjectColumnEvent;
  public: PublicEvent;
  pull_request: PullRequestEvent;
  pull_request_review: PullRequestReviewEvent;
  pull_request_review_comment: PullRequestReviewCommentEvent;
  push: PushEvent;
  release: ReleaseEvent;
  repository: RepositoryEvent;
  repository_dispatch: RepositoryDispatchEvent;
  repository_import: RepositoryImportEvent;
  repository_vulnerability_alert: RepositoryVulnerabilityAlertEvent;
  secret_scanning_alert: SecretScanningAlertEvent;
  security_advisory: SecurityAdvisoryEvent;
  sponsorship: SponsorshipEvent;
  star: StarEvent;
  status: StatusEvent;
  team: TeamEvent;
  team_add: TeamAddEvent;
  watch: WatchEvent;
  workflow_dispatch: WorkflowDispatchEvent;
  workflow_run: WorkflowRunEvent;
}

export type Asset = ReleaseAsset;
export type WebhookEvent = Schema;
export type WebhookEventMap = EventPayloadMap;
export type WebhookEventName = keyof EventPayloadMap;
